var express = require('express');
var app = express();
var server = require('http').Server(app);
var io = require('socket.io')(server);
var Vector = require('v2d');

require('./model/utils/extend-module').extendArray();

var Worm = require('./model/worm');
var Food = require('./model/food');
var Wormhole = require('./model/wormhole');
var Team = require('./model/team');

app.use(express.static(__dirname + '/public'));

server.listen(process.env.PORT || 3000, function() {
	console.log("Socket listening on port %d ", this.address().port);
});


/*------------------------------------------*/
/*------------------ GAME ------------------*/
/*------------------------------------------*/

var wormID = 0;
var worms = new Array();
var ranking = new Array();
var teams = new Array();

var foodID = 0;
var foodMax = 300;
var foodCount = 0;
var foods = new Array();
 
var wormholeID = 0;
var wormholes = new Array();

createFood();
setInterval(supplyFood, 3000);

function createFood() {
	for(var i = 0; i < foodMax; i++) {
		var randomX = (Math.random() * 3980) + 10;
		var randomY = (Math.random() * 3980) + 10;
		foods.push(new Food(foodID, randomX, randomY, null, null, true));
		foodCount++;
		foodID++
	}
}

function supplyFood() {
	if(foodCount < foodMax) {
		var randomX = (Math.random() * 3980) + 10;
		var randomY = (Math.random() * 3980) + 10;
		supplyFoodOn(randomX, randomY, null, true, null);
	}
}

function supplyFoodOn(x, y, color, autoGenerated, points) {
	var food = new Food(foodID, x, y, color, points, autoGenerated);
	foods.push(food);
	io.sockets.emit('suppliedFood', food);
	if(food.autoGenerated) {
		foodCount++;
	}
	foodID++;
}

setInterval(updateTopTen, 5000);

function updateTopTen() {
	io.sockets.emit('updateTopTen', getTopTen());
}

function getTopTen() {
	ranking = worms.clone();
    ranking.sortBy('score');
	return ranking.first(10);
}

setInterval(updateWanted, 5000);

function updateWanted() {
	var wanted = getWanted();
	if(wanted && wanted.kills) {
		io.sockets.emit('updateWanted', wanted);
	} else {
		io.sockets.emit('updateWanted', null);
	}
}

function getWanted() {
	var sortedByKills = worms.clone();
	sortedByKills.sortBy('kills');
	return sortedByKills.first();
}

io.sockets.on('connection', function(socket) {

	bindEvents();
	
	var myID;

	////////////// Movement variables //////////////
	var polarVelocity = {r: 120, w: 0};
	var angularVelocity = Math.PI * 1;
	var destinyDirection = Vector.unit(Vector(1,1));
	////////////////////////////////////////////////

	var gameLoopID;
	var nitroLoopID;

	function gameLoop() {
		var myWorm = worms.get(myID);

		var now = Date.now();
		var then = myWorm.lastUpdate == null ? Date.now() : myWorm.lastUpdate;
		var delta = (now - then) / 1000;
		
		myWorm.lastUpdate = now;
		
		updateVelocity(delta);
		updatePosition(delta);
		updateHeadRotation();
		updateRank();
		detectCollisions();

		if(myWorm) {
			socket.emit('wormUpdated', myWorm);
			socket.broadcast.emit('otherWormUpdated', myWorm);
		}
	}

	function nitroLoop() {
		var myWorm = worms.get(myID);
		if(myWorm.score >= 5) {
			myWorm.nitro();
			supplyFoodOn(myWorm.tail().x, myWorm.tail().y, myWorm.color, null, 5);
		} else {
			onSlowDown();
			clearInterval(nitroLoopID);
		}
	}


	//////////////// Events Handlers ////////////////
	function bindEvents() {
		socket.on('wormLogin', onWormLogin);
		socket.on('destinyUpdate', onDestinyUpdate);
		socket.on('speedUp', onSpeedUp);
		socket.on('slowDown', onSlowDown);
		socket.on('wormholeCreation', onWormholeCreation);
		socket.on('disconnect', onDisconnect);
	}


	function onWormLogin(data) {

		myID = wormID;

		if(data.teamname) {
			if(teams.get(data.teamname)) {
				teams.get(data.teamname).addMember(myID);
			} else {
				teams.push(new Team(data.teamname, myID, data.color));
			}
			socket.broadcast.emit('teamUpdate', teams.get(data.teamname));
		}

		var color = data.teamname ? teams.get(data.teamname).color : data.color;

		var worm = new Worm(wormID, data.nickname, color, data.teamname);

		socket.emit('loginSuccess', { worm: worm, otherWorms: worms, foods: foods, wormholes: wormholes, team: teams.get(data.teamname) });

		worms.push(worm);

		socket.broadcast.emit('newWormLogin', worm);

		wormID++;

		gameLoopID = setInterval(gameLoop, 1000/60);
	}

	function onDestinyUpdate(state) {
		updateDestiny(state);
	}

	function onSpeedUp(data) {
		var myWorm = worms.get(myID);

		if(myWorm.score >= 5) {
			myWorm.onSpeed = true;
			polarVelocity = {r: 200, w: polarVelocity.w}; // speed * 1.8
			angularVelocity -= angularVelocity / 4; // less mobility on turns
			nitroLoopID = setInterval(nitroLoop, 1000/4);
		}
	}

	function onSlowDown(data) {
		var myWorm = worms.get(myID);

		myWorm.onSpeed = false;
		polarVelocity = {r: 120, w: polarVelocity.w};
		angularVelocity = Math.PI * 1;
		clearInterval(nitroLoopID);
	}

	function onWormholeCreation(data) {
		var myWorm = worms.get(myID);
		
		if(myWorm.wormholeAvailable()) {
			var wormhole = new Wormhole(myWorm); 
			wormholes.push(wormhole);
			myWorm.wormholeCreated = true;
			wormholeID++
			socket.emit('wormholeCreated', wormhole);
			socket.broadcast.emit('newWormhole', wormhole);
		}
	}

	function onDisconnect(data) {
		var myWorm = worms.get(myID);

		clearInterval(gameLoopID);
		clearInterval(nitroLoopID);

		if(wormholes.get(myID)) {
			wormholes.removeByID(myID);
			io.sockets.emit('wormholeCollapsed', myID);
		}


		if(myWorm.teamname) {
			var team = teams.get(myWorm.teamname);
			team.removeMember(myWorm.id);
			if(team.members.length > 0) {
				socket.broadcast.emit('teamUpdate', team);
			} else {
				teams.removeByID(team.id);				
			}
		}

		worms.removeByID(myID);
		io.sockets.emit('otherWormDisconnect', myID);
	}
	/////////////////////////////////////////////////


	function updateDestiny(state) {
		destinyDirection = Vector.unit(Vector.dif(mousePosition(state), centeredPosition()));
	}

	function updateVelocity(delta) {
		var theta = polarVelocity.w;

		if(!correctDirection()) {
			var correctAngle = Vector.toPolar(destinyDirection).w;

			var distanceBySum;                           ; 
			var distanceBySub;

			if(theta >= correctAngle) {
				// -PI--------ca---|-----t-------PI //
				distanceBySub = Math.abs(theta - correctAngle);
				distanceBySum = Math.abs(correctAngle - (-Math.PI)) + Math.abs(Math.PI - theta); 
			} else {
				// -PI-----t-------|-------ca-----PI //
				distanceBySub = Math.abs(theta - (-Math.PI)) + Math.abs(Math.PI - correctAngle);
				distanceBySum = Math.abs(correctAngle - theta);
			}

			if(distanceBySum <= distanceBySub) {
				theta += angularVelocity * delta;
			} else {
				theta -= angularVelocity * delta;
			}

			theta = setAngle(theta);
		}
		
		polarVelocity = {r: polarVelocity.r, w: theta};
	}

	function updatePosition(delta) {
		worms.get(myID).moveTo(currentVelocity(delta));
	}

	function updateHeadRotation(delta) {
		var angleRadians = polarVelocity.w;
		worms.get(myID).lookTo(angleRadians * (180 / Math.PI));
	}

	function detectCollisions() {
		detectWormholesCollisions();
		detectFoodCollisions();
		if(mustDead()) {
			dropFoodByDead();
			socket.emit('dead', null);
			socket.disconnect();
		}
	}

	function updateRank() {
		worms.get(myID).rank = ranking.getIndex(myID) + 1;
	};

	function detectWormholesCollisions() {
		var myWorm = worms.get(myID);

		for(var i = 0; i < wormholes.length; i++) {
			var wormhole = wormholes[i];
			if(myWorm.collideWormhole(wormhole)) {
				myWorm.teleport(wormhole);
				socket.emit('teleportation', null);
			}
		}
	}

	function detectFoodCollisions() {
		var myWorm = worms.get(myID);

		for(var i = 0; i < foods.length; i++) {
			var food = foods[i];
			if(myWorm.collideFood(food)) {
				myWorm.eat(food);
				io.sockets.emit('foodSwallowed', food.id);
				foods.removeByID(food.id);
				if(food.autoGenerated) {
					foodCount--;
				}
			}
		}
	}

	function mustDead() {
		return detectWormsCollisions() || detectBordersCollisions();
	}

	function detectWormsCollisions() {
		var myWorm = worms.get(myID);
		var collision = false;

		for(var i = 0; i < worms.length; i++) {
			var worm = worms[i];
			collision = collision || myWorm.collideHeadToBody(worm);		
			if(collision && itsMostWanted(myWorm)) {
				worm.collectBounty(myWorm);
				io.sockets.emit('wantedDead', worm.id);
				break;
			}
		}

		return collision;
	}

	function itsMostWanted(worm) {
		var wanted = getWanted();
		return wanted && worm.id == wanted.id;
	}

	function detectBordersCollisions() {
		return worms.get(myID).collideWithBorder();
	}

	function dropFoodByDead() {
		var myWorm = worms.get(myID);

		for(var i = 0; i < myWorm.segments.length; i++) {
			var segment = myWorm.segments[i];
			dropFoodOn(segment);
		}
	}

	function dropFoodOn(segment) {
		var foodX = segment.x - 20 + Math.random() * 40;
		var foodY = segment.y - 20 + Math.random() * 40;
		supplyFoodOn(foodX, foodY, worms.get(myID).color);
	}


	function mousePosition(state) {
		return Vector(state.mouseX, state.mouseY);
	}

	function currentPosition() {
		var myWorm = worms.get(myID);
		return Vector(myWorm.x, myWorm.y);
	}

	function centeredPosition() {
		return Vector(500, 300);
	}

	function currentVelocity(delta) {
		return Vector.scl(Vector.fromPolar(polarVelocity), delta);
	}

	function currentDirection() {
		return Vector.fromPolar(Vector(1, polarVelocity.r));
	}

	function correctDirection() {
		var distance = Vector.len(Vector.dif(destinyDirection, currentDirection()));
		return distance < 0.000001;
	}

	function setAngle(angle) {
		angle = angle > Math.PI ? angle - 2 * Math.PI : angle;
		angle = angle < -Math.PI ? angle + 2 * Math.PI : angle; 
		return angle;
	}

});